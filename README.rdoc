= micromidi

A DSL for MIDI in Ruby

{pic}[http://images.treetrouble.net/images/midi.png]

== Features
 
* Simplified realtime MIDI IO
* Construct message objects
* Cross-platform compatibile using MRI or JRuby.

== Installation

  gem install micromidi
  
== Requirements

Ruby 1.9.2+ or JRuby in 1.9 mode

Requires {midi-eye}[http://github.com/arirusso/midi-eye], {midi-message}[http://github.com/arirusso/midi-message] and {unimidi}[http://github.com/arirusso/unimidi].  These should install automatically with the gem.

== Usage

  require "micromidi"
  
==== Output
  
Here's an example that sends some MIDI messages to a {unimidi}[http://github.com/arirusso/unimidi] output.  ({read more here about selecting an output...}[http://github.com/arirusso/unimidi/blob/master/examples/select_a_device.rb])

  @output = UniMIDI::Output.first.open
  
  MIDI.message(@output) do
    
    note "C4"
    off 

    cc 5, 120
  
    play "C3", 0.5
  
  end 

As you might expect, the code in the block sends the following to <em>@output</em>: 

* note C4 
* note-off for C4, since that was the last note sent
* sets controller number 5 to 120
* note C3, waits half of a second and then note-off for C3

==== Sticky Message Values

If you use MIDI alot, you may have noticed that there was no mention of <em>MIDI channel</em> or <em>velocity</em> in the last example.  Most of the time, sending a note-on or note-off message requires those values.

That's because channel and velocity are sticky values in micromidi.  They default to 0 and 100, respectively.  These sticky values will be used by any commands that need them.  One can also pass a channel or velocity value explicitly to a command overriding the sticky value.

Here's an example where the sticky values are used, changed and overriden.

  MIDI.message(@output) do

    channel 1

    note "C4"
    off

    velocity 60

    note "E5", :channel => 2
    off

    channel 3

    note "C3"
    off
  
  end 

In this case the following is sent to <em>@output</em>:

* note C4 (channel 1, vel 100)
* note-off C4 (channel 1, vel 100)
* note E5 (channel 2, vel 60)
* note-off E5 (channel 2, vel 60)
* note C3 (channel 3, vel 60)
* note-off C3 (channel 3, vel 60)

==== Input
  
Input works via configuration and binding events.

Note that when you open a micromidi block, you can pass in as many inputs and outputs as you like, although input methods won't do anything if there is no input passed in.  If there are no inputs OR outputs passed in, output methods can be called but they will only {produce message objects without sending them anywhere}[http://github.com/arirusso/micromidi/blob/master/examples/midi_message_objects.rb].  

  input = UniMIDI::Input.first.open

  MIDI.message(input, output) do
    
    thru_unless :note
    
    listen_for :note do |message|
      message.note += 12
      output message
    end
  
    wait_for_input
      
  end
  
== To-do

* sysex Messages 
* more doc
 
== Documentation

* {rdoc}[http://rubydoc.info/github/arirusso/micromidi] 

== Author

* {Ari Russo}[http://github.com/arirusso] <ari.russo at gmail.com>

== License

Apache 2.0, See the file LICENSE

Copyright (c) 2011 Ari Russo
